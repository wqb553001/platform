package com.doctor.assistant.scheduleserver;import org.junit.Test;import java.time.Duration;import java.time.Instant;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;public class ForkJoinTest {    class ForkJoinInner extends RecursiveTask<Long> {        public static final long THEASHOD = 10000l;        private long begin;        private long end;        public ForkJoinInner(long begin, long end) {            this.begin = begin;            this.end = end;        }        @Override        protected Long compute() {            long len = this.end - this.begin;            if(len <= THEASHOD){                long sum = 0;                while (begin <= end){                    sum = sum + begin;                    begin ++;                }//                for (long i = begin;i<=end;i++)//                    sum += i;                return sum;            }else{                Long mid = (begin + end) / 2;                ForkJoinInner left = new ForkJoinInner(begin, mid);                left.fork();                ForkJoinInner right = new ForkJoinInner(mid + 1, end);                right.fork();                return left.join() + right.join();            }        }    }    @Test    public void forkJoinTest(){        Instant begin = Instant.now();        ForkJoinPool forkJoinPool = new ForkJoinPool();        ForkJoinTask<Long> forkJoinInner = new ForkJoinInner(0, 3000000000l);        Long result = forkJoinPool.invoke(forkJoinInner);        Instant end = Instant.now();        System.out.println("结果："+ result+" ；用时：" + Duration.between(begin, end).toMillis());        List a = new ArrayList();        a = new LinkedList();    }}